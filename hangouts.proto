/*

hangouts.proto - Unofficial, reverse engineered Protocol Buffers for Google's
Hangouts chat protocol.

Originally based on Darryl Pogue's reversed engineered proto file from an early
version of Hangouts for Android: https://gist.github.com/dpogue/5692114

Field and message name should generally match those used by Google, with the
major exception that "Client" prefixes have been removed.

 */

// proto2 is required because we need to be able to serialize default values:
syntax = "proto2";

// Describes which Hangouts client is active.
enum ActiveClientState {
  // No client is active.
  ACTIVE_CLIENT_STATE_NO_ACTIVE = 0;
  // This is the active client.
  ACTIVE_CLIENT_STATE_IS_ACTIVE = 1;
  // Other client is active.
  ACTIVE_CLIENT_STATE_OTHER_ACTIVE = 2;
}

// The state of do-not-disturb mode. Not to be confused with DndSetting, which
// is used to change the state of do-not-disturb mode.
message DoNotDisturbSetting {
  // Whether do-not-disturb mode is enabled.
  optional bool do_not_disturb = 1;
  // Timestamp when do-not-disturb mode expires.
  optional uint64 expiration_timestamp = 2;
  // Timestamp when this setting was applied. Not present when this message
  // comes from a notification.
  optional uint64 version = 3;
}

message NotificationSettings {
  optional DoNotDisturbSetting dnd_settings = 1;
}

enum FocusType {
  FOCUS_TYPE_UNKNOWN = 0;
  FOCUS_TYPE_FOCUSED = 1;
  FOCUS_TYPE_UNFOCUSED = 2;
}

enum FocusDevice {
  FOCUS_DEVICE_UNSPECIFIED = 0;
  FOCUS_DEVICE_DESKTOP = 20;
  FOCUS_DEVICE_MOBILE = 300;
}

// Identifies a conversation.
message ConversationId {
  // Unique identifier for a conversation.
  optional string id = 1;
}

// Identifies a user.
message ParticipantId {
  // Unique identifier for a user's Google account.
  optional string gaia_id = 1;
  // Seems to always be the same as gaia_id.
  optional string chat_id = 2;
}

// Indicates whether Hangouts is active (running in the foreground) on
// different types of devices.
message DeviceStatus {
  // True if a mobile phone is active.
  optional bool mobile = 1;
  // True if a desktop or laptop is active.
  optional bool desktop = 2;
  // True if a tablet is active.
  optional bool tablet = 3;
}

message LastSeen {
  required uint64 last_seen_timestamp = 1; //in microseconds
  optional uint64 usec_since_last_seen = 2;
}

message Location {
  optional uint64 type = 1;
  optional double lat = 2;
  optional double lng = 3;
  optional uint64 timestamp_msec = 4;
  optional uint64 accuracy_meters = 5;
  optional string display_name = 6;
}

enum CallType {
  CALL_TYPE_NONE = 0;
  CALL_TYPE_PSTN = 1;
  CALL_TYPE_HANGOUT = 2;
}

message InCall {
  optional CallType call_type = 1;
}

message Presence {
  optional bool reachable = 1;
  optional bool available = 2;
  repeated Location device_location = 3;
  optional InCall in_call = 5;
  optional DeviceStatus device_status = 6;
  optional MoodSetting mood_setting = 9;
  optional LastSeen last_seen = 10;
  
  //TODO
  //optional RichStatus rich_status = 4;
  //optional DeviceActivity device_activity = 7;
}

message PresenceResult {
  optional ParticipantId user_id = 1;
  optional Presence presence = 2;
}

enum TypingType {
  TYPING_TYPE_UNKNOWN = 0;
  // Started typing.
  TYPING_TYPE_STARTED = 1;
  // Stopped typing with inputted text.
  TYPING_TYPE_PAUSED = 2;
  // Stopped typing with no inputted text.
  TYPING_TYPE_STOPPED = 3;
}

message ClientIdentifier {
  // (client_id in hangups).
  optional string resource = 1;
  // unknown (header_id in hangups).
  optional string client_id = 2;
  //optional string self_fanout_id = 3;
  optional string participant_log_id = 4;
}

enum ClientPresenceStateType {
  CLIENT_PRESENCE_STATE_UNKNOWN = 0;
  CLIENT_PRESENCE_STATE_NONE = 1;
  CLIENT_PRESENCE_STATE_MOBILE = 10;
  CLIENT_PRESENCE_STATE_MOBILE_ACTIVE = 20;
  CLIENT_PRESENCE_STATE_DESKTOP_IDLE = 30;
  CLIENT_PRESENCE_STATE_DESKTOP_ACTIVE = 40;
}

message ClientPresenceState {
  optional ClientIdentifier identifier = 1;
  optional ClientPresenceStateType state = 2;
  optional uint64 expiration_timestamp = 3;
}

enum NotificationLevel {
  NOTIFICATION_LEVEL_UNKNOWN = 0;
  // Notifications are disabled.
  NOTIFICATION_LEVEL_QUIET = 10;
  NOTIFICATION_LEVEL_DING = 20;
  //NOTIFICATION_LEVEL_IMPORTANT_ONLY = 25;
  // Notifications are enabled.
  NOTIFICATION_LEVEL_RING = 30;
  //NOTIFICATION_LEVEL_USE_GLOBAL_DEFAULT = 100;
}

message UserEventState {
  optional ParticipantId user_id = 1;
  optional string client_generated_id = 2;
  optional NotificationLevel notification_level = 3;
}

enum SegmentType {
  // Segment is text.
  SEGMENT_TYPE_TEXT = 0;
  // Segment is a line break.
  SEGMENT_TYPE_LINE_BREAK = 1;
  // Segment is hyperlinked text.
  SEGMENT_TYPE_LINK = 2;
  //SEGMENT_TYPE_USER_MENTION = 3;
  //SEGMENT_TYPE_HASHTAG = 4;
  //SEGMENT_TYPE_ALL_USER_MENTION = 5;
}

message Formatting {
  optional bool bold = 1;
  optional bool italics = 2;
  optional bool strikethrough = 3;
  optional bool underline = 4;
}

message LinkData {
  optional string link_target = 1;
}

// message UserMentionData {
  // optional int64 user_gaia_id = 1;
  // optional string user_id = 2;
  // optional string email = 3;
// }

// message HashtagData {
  // optional string search_text = 1;
// }

// A segment of a message. Message are broken into segments that may be of
// different types and have different formatting.
message Segment {
  // Note: This field is required because Hangouts for Chrome misbehaves if it
  // isn't serialized.
  required SegmentType type = 1;
  // The segment text. For line breaks, may either be empty or contain new line
  // character.
  optional string text = 2;
  // Formatting for this segment.
  optional Formatting formatting = 3;
  // Link data for this segment, if it is a link.
  optional LinkData link_data = 4;
  //optional UserMentionData user_mention_data = 5;
  //optional HashtagData hashtag_data = 6;
}

// A type of embedded item.
enum ItemType {
  ITEM_TYPE_THING = 0;
  // Google Plus photo.
  ITEM_TYPE_PLUS_PHOTO = 249;
  ITEM_TYPE_PLACE = 335;
  // Google Map place.
  ITEM_TYPE_PLACE_V2 = 340;
}

// Google Plus photo that can be embedded in a chat message.
message PlusPhoto {

  // Metadata for displaying an image thumbnail.
  message Thumbnail {

    // URL to navigate to when thumbnail is selected (a Google Plus album
    // page).
    optional string url = 1;
    // URL of thumbnail image.
    optional string image_url = 4;
    // Image width in pixels.
    optional uint64 width_px = 10;
    // Image height in pixels.
    optional uint64 height_px = 11;
  }

  // Media type.
  enum MediaType {
    MEDIA_TYPE_UNKNOWN = 0;
    MEDIA_TYPE_PHOTO = 1;
    MEDIA_TYPE_VIDEO = 2;
    MEDIA_TYPE_ANIMATED_PHOTO = 4;
  }

  // Thumbnail.
  optional Thumbnail thumbnail = 1;
  // Owner obfuscated ID.
  optional string owner_obfuscated_id = 2;
  // Album ID.
  optional string album_id = 3;
  // Photo ID.
  optional string photo_id = 4;
  // URL of full-sized image.
  optional string url = 6;
  // URL of image thumbnail.
  optional string original_content_url = 10;
  // The media type.
  optional MediaType media_type = 13;
  // List of stream ID parameters.
  repeated string stream_id = 14;
  // The download URL for a video
  optional string download_url = 20;
}

// Place that can be embedded in a chat message via Google Maps.
message Place {

  // Representative image of a place.
  message RepresentativeImage {
    // URL of image.
    optional string url = 2;
  }

  // Google Maps URL pointing to the map coordinates.
  optional string url = 1;
  // Name of map location.
  optional string name = 3;
  // Representative image of the place (map with pin).
  optional RepresentativeImage representative_image = 185;
}

// An item of some type embedded in a chat message.
message EmbedItem {
  // List of embedded item types in this message.
  repeated ItemType type = 1;
  // For photos this is not given, for maps, it's the URL of the map.
  optional string id = 2;
  // Embedded Google Plus photo.
  optional PlusPhoto plus_photo = 27639957;
  // Embedded Google Map of a place.
  optional Place place = 35825640;
}

// An attachment for a chat message.
message Attachment {
  optional EmbedItem embed_item = 1;
}

// Chat message content.
message MessageContent {
  repeated Segment segment = 1;
  repeated Attachment attachment = 2;
}

// Annotation that can be applied to a chat message event. The only known use
// for this is "\me" actions supported by the Chrome client (type 4).
message EventAnnotation {
  // Annotation type.
  optional int32 type = 1;
  // Optional annotation string value.
  optional string value = 2;
}

// A chat message in a conversation.
message ChatMessage {
  // Optional annotation to attach to message.
  repeated EventAnnotation annotation = 2;
  // The message's content.
  optional MessageContent message_content = 3;

  // TODO:
  // always 0? = 1;
}

enum MembershipChangeType {
  MEMBERSHIP_CHANGE_TYPE_JOIN = 1;
  MEMBERSHIP_CHANGE_TYPE_LEAVE = 2;
}

message Participant {
  optional ParticipantId id = 1;
  optional string first_name = 2;
  optional string full_name = 3;
  optional string profile_photo_url = 4;
}

enum LeaveReason {
 LEAVE_REASON_UNKNOWN = 0;
 LEAVE_REASON_HISTORY_POLICY_CHANGE = 1;
 LEAVE_REASON_USER_INITIATED = 2;
}

message MembershipChange {
  optional MembershipChangeType type = 1;
  repeated Participant participant = 2;
  repeated ParticipantId participant_ids = 3;
  optional LeaveReason leave_reason = 4;
}

message ConversationRename {
  optional string new_name = 1;
  optional string old_name = 2;
}

enum HangoutEventType {
  HANGOUT_EVENT_TYPE_UNKNOWN = 0;
  HANGOUT_EVENT_TYPE_START = 1;
  HANGOUT_EVENT_TYPE_END = 2;
  HANGOUT_EVENT_TYPE_JOIN = 3;
  HANGOUT_EVENT_TYPE_LEAVE = 4;
  HANGOUT_EVENT_TYPE_COMING_SOON = 5;
  HANGOUT_EVENT_TYPE_ONGOING = 6;
}

enum HangoutMediaType {
  HANGOUT_MEDIA_TYPE_UNKNOWN = 0;
  HANGOUT_MEDIA_TYPE_AUDIO_VIDEO = 1;
  HANGOUT_MEDIA_TYPE_AUDIO_ONLY = 2;
  HANGOUT_MEDIA_TYPE_PUSH_TO_TALK = 3;
}

message HangoutEvent {
  optional HangoutEventType event_type = 1;
  repeated ParticipantId participant_id = 2;
  optional uint64 hangout_duration_secs = 3;
  optional ConversationId transferred_conversation_id = 4;
  optional uint64 refresh_timeout_secs = 5;
  optional bool is_peridoic_refresh = 6;
  optional HangoutMediaType media_type = 7;
}

message OTRModification {
  optional OffTheRecordStatus old_otr_status = 1;
  optional OffTheRecordStatus new_otr_status = 2;
  optional OffTheRecordToggle old_otr_toggle = 3;
  optional OffTheRecordToggle new_otr_toggle = 4;
}

// Whether the OTR toggle is available to the user.
enum OffTheRecordToggle {
  OFF_THE_RECORD_TOGGLE_UNKNOWN = 0;
  OFF_THE_RECORD_TOGGLE_ENABLED = 1;
  OFF_THE_RECORD_TOGGLE_DISABLED = 2;
}

enum OffTheRecordStatus {
  OFF_THE_RECORD_STATUS_UNKNOWN = 0;
  // Conversation is off-the-record (history disabled).
  OFF_THE_RECORD_STATUS_OFF_THE_RECORD = 1;
  // Conversation is on-the-record (history enabled).
  OFF_THE_RECORD_STATUS_ON_THE_RECORD = 2;
}

enum SourceType {
  SOURCE_TYPE_UNKNOWN = 0;
  SOURCE_TYPE_MOBILE = 1;
  SOURCE_TYPE_WEB = 2;
}

enum EventType {
  EVENT_TYPE_UNKNOWN = 0;
  EVENT_TYPE_REGULAR_CHAT_MESSAGE = 1;
  EVENT_TYPE_SMS = 2;
  EVENT_TYPE_VOICEMAIL = 3;
  EVENT_TYPE_ADD_USER = 4;
  EVENT_TYPE_REMOVE_USER = 5;
  EVENT_TYPE_CONVERSATION_RENAME = 6;
  EVENT_TYPE_HANGOUT = 7;
  EVENT_TYPE_PHONE_CALL = 8;
  EVENT_TYPE_OTR_MODIFICATION = 9;
  EVENT_TYPE_PLAN_MUTATION = 10; //DEPRECATED_10
  EVENT_TYPE_MMS = 11;
  EVENT_TYPE_DEPRECATED_12 = 12;
  EVENT_TYPE_OBSERVED_EVENT = 13;
  EVENT_TYPE_GROUP_LINK_SHARING_MODIFICATION = 14;
}

message HashModifier {
  optional string update_id = 1;
  optional uint64 hash_diff = 2;
  optional uint64 version = 4;
}

// Event that becomes part of a conversation's history.
message Event {
  // ID of the conversation this event belongs to.
  optional ConversationId conversation_id = 1;
  // ID of the user that sent this event.
  optional ParticipantId sender_id = 2;
  // Timestamp when the event occurred.
  optional uint64 timestamp = 3;
  optional UserEventState self_event_state = 4;
  optional SourceType source_type = 6;
  optional ChatMessage chat_message = 7;
  optional MembershipChange membership_change = 9;
  optional ConversationRename conversation_rename = 10;
  optional HangoutEvent hangout_event = 11;
  // Unique ID for the event.
  optional string event_id = 12;
  optional uint64 expiration_timestamp = 13;
  optional OTRModification otr_modification = 14;
  optional bool advances_sort_timestamp = 15;
  optional OffTheRecordStatus event_otr = 16;
  optional bool persisted = 17;
  optional DeliveryMedium delivery_medium = 20;
  // The event's type.
  optional EventType event_type = 23;
  // Event version timestamp.
  optional uint64 event_version = 24;
  optional HashModifier hash_modifier = 26;
  optional GroupLinkSharingModification group_link_sharing_modification = 31;
}

enum ConversationType {
  CONVERSATION_TYPE_UNKNOWN = 0;
  // Conversation is one-to-one (only 2 participants).
  CONVERSATION_TYPE_ONE_TO_ONE = 1;
  // Conversation is group (any number of participants).
  CONVERSATION_TYPE_GROUP = 2;
}

message UserReadState {
  optional ParticipantId participant_id = 1;
  optional uint64 latest_read_timestamp = 2;

  // TODO: is latest_read_timestamp always 0?
}

enum ConversationStatus {
  CONVERSATION_STATUS_UNKNOWN = 0;
  // User is invited to conversation.
  CONVERSATION_STATUS_INVITED = 1;
  // User is participating in conversation.
  CONVERSATION_STATUS_ACTIVE = 2;
  // User has left conversation.
  CONVERSATION_STATUS_LEFT = 3;
}

enum ConversationView {
  CONVERSATION_VIEW_UNKNOWN = 0;
  // Conversation is in inbox.
  CONVERSATION_VIEW_INBOX = 1;
  // Conversation has been archived.
  CONVERSATION_VIEW_ARCHIVED = 2;
}

enum DeliveryMediumType {
  DELIVERY_MEDIUM_UNKNOWN = 0;
  DELIVERY_MEDIUM_BABEL = 1;
  DELIVERY_MEDIUM_GOOGLE_VOICE = 2;
  DELIVERY_MEDIUM_LOCAL_SMS = 3;
}

message DeliveryMedium {
  optional DeliveryMediumType medium_type = 1;
  // Phone number to use for sending Google Voice messages.
  optional PhoneNumber self_phone = 2;
}

message DeliveryMediumOption {
  optional DeliveryMedium delivery_medium = 1;
  optional bool current_default = 2;
  optional bool primary = 3;
}

enum InvitationAffinity {
  INVITE_AFFINITY_UNKNOWN = 0;
  INVITE_AFFINITY_HIGH = 1;
  INVITE_AFFINITY_LOW = 2;
}

message UserConversationState {
   optional string client_generated_id = 2;
   optional UserReadState self_read_state = 7;
   optional ConversationStatus status = 8;
   optional NotificationLevel notification_level = 9;
   repeated ConversationView view = 10;
   optional ParticipantId inviter_id = 11;
   optional uint64 invite_timestamp = 12;
   optional uint64 sort_timestamp = 13;
   optional uint64 active_timestamp = 14;
   optional InvitationAffinity invite_affinity = 15;
   //optional bool has_no_persistent_events = 16;
   repeated DeliveryMediumOption delivery_medium_option = 17;
   //optional bool is_guest = 21;
}

enum ParticipantType {
  PARTICIPANT_TYPE_UNKNOWN = 0;
  //PARTICIPANT_TYPE_INVALID = 1;
  PARTICIPANT_TYPE_GAIA = 2;
  PARTICIPANT_TYPE_OFF_NETWORK_PHONE = 3;
  //PARTICIPANT_TYPE_MALFORMED_PHONE_NUMBER = 4;
  //PARTICIPANT_TYPE_UNKNOWN_PHONE_NUMBER = 5;
  //PARTICIPANT_TYPE_ANONYMOUS_PHONE_NUMBER = 6;
}

enum InvitationStatus {
  INVITATION_STATUS_UNKNOWN = 0;
  INVITATION_STATUS_PENDING = 1;
  INVITATION_STATUS_ACCEPTED = 2;
  INVITATION_STATUS_NEEDED = 3;
}

message ConversationParticipantData {
  optional ParticipantId id = 1;
  optional string fallback_name = 2;
  optional InvitationStatus invitation_status = 3;
  optional PhoneNumber phone_number = 4;
  optional ParticipantType participant_type = 5;
  optional InvitationStatus new_invitation_status = 6;
}

enum ForceHistory {
  FORCE_HISTORY_UNKNOWN = 0;
  FORCE_HISTORY_NO = 1;
  //FORCE_HISTORY_ON = 2;
  //FORCE_HISTORY_OFF = 3;
}

enum NetworkType { //ER is this the same as DeliveryMediumType ?
  NETWORK_TYPE_UNKNOWN = 0;
  NETWORK_TYPE_BABEL = 1;
  NETWORK_TYPE_PHONE = 2;
}

// A conversation between two or more users.
message Conversation {
  optional ConversationId conversation_id = 1;
  optional ConversationType type = 2;
  optional string name = 3;
  optional UserConversationState self_conversation_state = 4;
  //repeated bytes deprecated5 = 5;
  //repeated bytes deprecated6 = 6;
  repeated UserReadState read_state = 8;
  // True if the conversation has an active Hangout.
  optional bool has_active_hangout = 9;
  // The conversation's "off the record" status.
  optional OffTheRecordStatus otr_status = 10;
  // Whether the OTR toggle is available to the user for this conversation.
  optional OffTheRecordToggle otr_toggle = 11;
  optional bool conversation_history_supported = 12;
  repeated ParticipantId current_participant = 13;
  repeated ConversationParticipantData participant_data = 14;
  optional bool is_temporary = 15;
  optional bool fork_on_external_invite = 16;
  repeated NetworkType network_type = 18;
  optional ForceHistory force_history_state = 19;
  optional bool is_group_link_sharing_enabled = 21;
  optional GroupLinkSharingStatus group_link_sharing_status = 22;
}

message EasterEgg {
  optional string message = 1;
}

enum BlockState {
  BLOCK_STATE_UNKNOWN = 0;
  BLOCK_STATE_BLOCK = 1;
  BLOCK_STATE_UNBLOCK = 2;
}

message BlockStateChange {
  optional ParticipantId participant_id = 1;
  optional BlockState new_block_state = 2;
}

message InvitationState {
  optional uint64 unread_invite_count = 1;
  optional uint64 latest_read_timestamp = 2;
}

enum ReplyToInviteType {
  REPLY_TO_INVITE_TYPE_UNKNOWN = 0;
  REPLY_TO_INVITE_TYPE_ACCEPT = 1;
  REPLY_TO_INVITE_TYPE_DECLINE = 2;
}

message Photo {
  // Picasa photo ID.
  optional string photo_id = 1;
  optional bool delete_albumless_source_photo = 2;
  // Optional Picasa user ID needed for photos from other accounts (eg. stickers).
  optional string user_id = 3;
  optional bool reference_original_photo = 4;

  // TODO: test delete_albumless_source_photo
}

message ExistingMedia {
  optional Photo photo = 1;
}

message EventRequestHeader {
  optional ConversationId conversation_id = 1;
  optional uint64 client_generated_id = 2;
  optional OffTheRecordStatus expected_otr = 3;
  optional DeliveryMedium delivery_medium = 4;
  optional EventType event_type = 5;
}

// Identifies the client.
enum ClientId {
  CLIENT_ID_UNKNOWN = 0;
  // Hangouts app for Android.
  CLIENT_ID_ANDROID = 1;
  // Hangouts app for iOS.
  CLIENT_ID_IOS = 2;
  // Hangouts Chrome extension.
  CLIENT_ID_CHROME = 3;  // AKA Quasar
  //CLIENT_ID_WEB = 4;
  // Hangouts web interface in Google Plus.
  CLIENT_ID_WEB_GPLUS = 5;
  // Hangouts web interface in Gmail.
  CLIENT_ID_WEB_GMAIL = 6;
  CLIENT_ID_BOT = 7;
  //CLIENT_ID_WEB_VIDEO_CALL = 8;
  CLIENT_ID_GLASS_SERVER = 9;
  CLIENT_ID_PSTN_BOT = 10;
  CLIENT_ID_TEE = 11;
  //CLIENT_ID_WEB_BIGTOP = 12;
  // Hangouts Chrome app ("ultraviolet").
  CLIENT_ID_ULTRAVIOLET = 13;
  CLIENT_ID_ROOM_SERVER = 14;
  //CLIENT_ID_WEB_STANDALONE_APP = 15;
  CLIENT_ID_SPEAKEASY = 16;
  CLIENT_ID_GOOGLE_VOICE = 17;
  CLIENT_ID_PROBER = 18;
  //CLIENT_ID_EXTERNAL = 19;
  //CLIENT_ID_BB_BOT = 23;
  //CLIENT_ID_POWWOW = 24;
  //CLIENT_ID_GPLUS_SERVER = 25;
  //CLIENT_ID_HANGOUTS_PUSHER = 26;
  CLIENT_ID_ANDROID_PSTN_ONLY = 27;
  //CLIENT_ID_REALTIME_SUPPORT = 28;
  //CLIENT_ID_CHAT_EXPUNGER = 29;
  //CLIENT_ID_CAPTIONS_BOT = 30;
  //CLIENT_ID_MESI = 31;
  //CLIENT_ID_REALTIME_MEDIA_JS = 32;
  //CLIENT_ID_WABEL_MEDIACALL = 33;
  CLIENT_ID_EXPRESSLANE = 34;
  CLIENT_ID_TEST_CLIENT = 35;
  //CLIENT_ID_WEB_CONTACTS = 36;
  //CLIENT_ID_WEB_CALLMEMAYBE = 37;
  //CLIENT_ID_GMAIL = 38;
  //CLIENT_ID_CASTOUTS = 39;
  //CLIENT_ID_IRONMAN_WEB = 40;
  //CLIENT_ID_IRONMAN_ANDROID = 41;
  //CLIENT_ID_IRONMAN_IOS = 42;
  //CLIENT_ID_ANONYMOUS_WEB_VIDEO_CALL = 43;
  // Hangouts web app (https://hangouts.google.com).
  CLIENT_ID_WEB_HANGOUTS = 44;
  //CLIENT_ID_WEB_SHORTLINK = 45;
  //CLIENT_ID_HOTLANE = 46;
  //CLIENT_ID_IOS_SHARE = 47;
  //CLIENT_ID_RIGEL = 48;
  //CLIENT_ID_PORTHOLE = 49;
  //CLIENT_ID_BOQ_EXPRESSLANE = 50;
}

// Build type of the client.
enum ClientBuildType {
  BUILD_TYPE_UNKNOWN = 0;
  // Web app.
  BUILD_TYPE_PRODUCTION_WEB = 1;
  BUILD_TYPE_DOGFOOD = 2;
  // Native app.
  BUILD_TYPE_PRODUCTION_APP = 3;
}

// The client and device version.
message ClientVersion {
  // Identifies the client.
  optional ClientId client_id = 1;
  // The client build type.
  optional ClientBuildType build_type = 2;
  // Client version.
  optional string major_version = 3;
  // Client version timestamp.
  optional uint64 version_timestamp = 4;
  // OS version string (for native apps).
  optional string device_os_version = 5;
  // Device hardware name (for native apps).
  optional string device_hardware = 6;
}

enum Device {
  DEVICE_UNKNOWN = 0;
  DEVICE_ANDROID_PHONE = 2;
  DEVICE_ANDROID_TABLET = 3;
  DEVICE_IOS_PHONE = 4;
  DEVICE_IOS_TABLET = 5;
}

enum Application {
  APPLICATION_BABEL = 407;
}

enum Platform {
  PLATFORM_UNKNOWN = 0;
  PLATFORM_NATIVE = 2;
}

message RtcClient {
  optional Device device = 1;
  optional Application application = 2;
  optional Platform platform = 3;
}

// Header for requests from the client to the server.
message RequestHeader {
  optional ClientVersion client_version = 1;
  optional ClientIdentifier client_identifier = 2;
  optional string language_code = 4;
  optional bool include_updated_conversation = 5;
  optional uint32 retry_attempt = 6;

  // TODO: incomplete
  //optional uint64 message_id = 3;
  //optional ClientInstrumentationInfo client_instrumentation_info = 3;
  optional RtcClient rtc_client = 7;
  //optional string client_generated_request_id = 8;
}

// Status of the response from the server to the client.
enum ResponseStatus {
  RESPONSE_STATUS_UNKNOWN = 0;
  RESPONSE_STATUS_OK = 1;
  RESPONSE_STATUS_BUSY = 2;
  RESPONSE_STATUS_UNEXPECTED_ERROR = 3;
  RESPONSE_STATUS_INVALID_REQUEST = 4;
  RESPONSE_STATUS_ERROR_RETRY_LIMIT = 5;
  RESPONSE_STATUS_ERROR_FORWARDED = 6;
  RESPONSE_STATUS_ERROR_QUOTA_EXCEEDED = 7;
  RESPONSE_STATUS_ERROR_INVALID_CONVERSATION = 8;
  RESPONSE_STATUS_ERROR_VERSION_MISMATCH = 9;
  RESPONSE_STATUS_ERROR_ACCESS_CHECK_FAILED = 10;
  RESPONSE_STATUS_ERROR_NOT_FOUND = 11;
}

// Header for responses from the server to the client.
message ResponseHeader {
  optional ResponseStatus status = 1;
  optional string error_description = 2;
  optional string debug_url = 3;
  optional string request_trace_id = 4;
  optional uint64 current_server_time = 5;
  optional uint64 backoff_duration_millis = 6;
  //optional string client_generated_request_id = 7;
  optional string localized_user_visible_error_message = 8;
  //optional string build_label = 10;
  //optional int32 changelist_number = 11;
}

// A user that can participate in conversations.
message Entity {
  // The user's ID.
  optional ParticipantId id = 9;
  // Optional user presence status.
  optional Presence presence = 8;
  optional bool invalid = 7;
  //optional Availability availability = 5;
  // Optional user properties.
  optional EntityProperties properties = 10;
  optional bool blocked = 11;
  //optional DomainProperties domain_properties = 12;
  optional ParticipantType entity_type = 13;
  //optional bool is_babel_user = 14;
  //optional BabelUserState babel_user_state = 15;
  enum PastHangoutState {
    PAST_HANGOUT_STATE_UNKNOWN = 0;
    PAST_HANGOUT_STATE_HAD_PAST_HANGOUT = 1;
    PAST_HANGOUT_STATE_NO_PAST_HANGOUT = 2;
  }
  optional PastHangoutState had_past_hangout_state = 16;
  //optional InvitationStatus invitation_status = 17;
  //optional bool is_anonymous_phone = 18;
}

message EntityProperties {
  optional ProfileType type = 1;
  optional string display_name = 2;
  optional string first_name = 3;
  // Photo URL with protocol scheme omitted (eg.
  // "//lh.googleusercontent.com/...").
  optional string photo_url = 4;
  repeated string email = 5;
  repeated string phone = 6;
  optional string location = 7;
  optional string organization = 8;
  optional string role = 9;
  optional bool in_users_domain = 10;
  optional Gender gender = 11;
  optional PhotoUrlStatus photo_url_status = 12;
  //repeated string circle_id_array = 13;
  //repeated ContactPhoneNumber phone_number_array = 14;
  optional string canonical_email = 15;
  //repeated ClientAffinity affinity_array = 16;
}

// Status of EntityProperties.photo_url.
enum PhotoUrlStatus {
  PHOTO_URL_STATUS_UNKNOWN = 0;
  // URL is a placeholder.
  PHOTO_URL_STATUS_PLACEHOLDER = 1;
  // URL is a photo set by the user.
  PHOTO_URL_STATUS_USER_PHOTO = 2;
}

enum Gender {
  GENDER_UNKNOWN = 0;
  GENDER_MALE = 1;
  GENDER_FEMALE = 2;
}

enum ProfileType {
  PROFILE_TYPE_NONE = 0;
  PROFILE_TYPE_ES_USER = 1;
  PROFILE_TYPE_PAGE = 2;
}

// State of a conversation and recent events.
message ConversationState {
  optional ConversationId conversation_id = 1;
  optional Conversation conversation = 2;
  repeated Event event = 3;
  //optional bool must_query_separately = 4;
  optional EventContinuationToken event_continuation_token = 5;
  //optional uint64 leave_timestamp = 6;
  //repeated DeleteAction delete_action_array = 7;
  //optional EventContinuationToken forward_continuation_token = 8;
}

// Token that allows retrieving more events from a position in a conversation.
// Specifying event_timestamp is sufficient.
message EventContinuationToken {
  optional string event_id = 1;
  optional bytes storage_continuation_token = 2;
  optional uint64 event_timestamp = 3;
}

// Specifies an entity to lookup by one of its properties.
message EntityLookupSpec {
  optional string gaia_id = 1;
  optional string jid = 2;
  optional string email = 3;
  optional string phone = 4;
  optional string chat_id = 5;
  // Whether create a gaia_id for off-network contacts (eg. Google Voice contacts).
  optional bool create_offnetwork_gaia = 6;
}

// A type of binary configuration option.
enum ConfigurationBitType {

  // TODO
  // HANGOUT_P2P_NOTICE_ACKNOWLEDGED

  CONFIGURATION_BIT_TYPE_UNKNOWN = 0;
  CONFIGURATION_BIT_TYPE_QUASAR_MARKETING_PROMO_DISMISSED = 1;
  CONFIGURATION_BIT_TYPE_GPLUS_SIGNUP_PROMO_DISMISSED = 2;
  CONFIGURATION_BIT_TYPE_CHAT_WITH_CIRCLES_ACCEPTED = 3;
  CONFIGURATION_BIT_TYPE_CHAT_WITH_CIRCLES_PROMO_DISMISSED = 4;
  CONFIGURATION_BIT_TYPE_ALLOWED_FOR_DOMAIN = 5;
  CONFIGURATION_BIT_TYPE_GMAIL_CHAT_ARCHIVE_ENABLED = 6;
  CONFIGURATION_BIT_TYPE_GPLUS_UPGRADE_ALLOWED_FOR_DOMAIN = 7;
  CONFIGURATION_BIT_TYPE_RICH_PRESENCE_ACTIVITY_PROMO_SHOWN = 8;
  CONFIGURATION_BIT_TYPE_RICH_PRESENCE_DEVICE_PROMO_SHOWN = 9;
  CONFIGURATION_BIT_TYPE_RICH_PRESENCE_IN_CALL_STATE_PROMO_SHOWN = 10;
  CONFIGURATION_BIT_TYPE_RICH_PRESENCE_MOOD_PROMO_SHOWN = 11;
  CONFIGURATION_BIT_TYPE_CAN_OPT_INTO_GV_SMS_INTEGRATION = 12;
  CONFIGURATION_BIT_TYPE_GV_SMS_INTEGRATION_ENABLED = 13;
  CONFIGURATION_BIT_TYPE_GV_SMS_INTEGRATION_PROMO_SHOWN = 14;
  CONFIGURATION_BIT_TYPE_BUSINESS_FEATURES_ELIGIBLE = 15;
  CONFIGURATION_BIT_TYPE_BUSINESS_FEATURES_PROMO_DISMISSED = 16;
  CONFIGURATION_BIT_TYPE_BUSINESS_FEATURES_ENABLED = 17;
  CONFIGURATION_BIT_TYPE_UNKNOWN_18 = 18;
  CONFIGURATION_BIT_TYPE_RICH_PRESENCE_LAST_SEEN_MOBILE_PROMO_SHOWN = 19;
  CONFIGURATION_BIT_TYPE_RICH_PRESENCE_LAST_SEEN_DESKTOP_PROMPT_SHOWN = 20;
  CONFIGURATION_BIT_TYPE_RICH_PRESENCE_LAST_SEEN_MOBILE_PROMPT_SHOWN = 21;
  CONFIGURATION_BIT_TYPE_RICH_PRESENCE_LAST_SEEN_DESKTOP_PROMO_SHOWN = 22;
  CONFIGURATION_BIT_TYPE_CONVERSATION_INVITE_SETTINGS_SET_TO_CUSTOM = 23;
  CONFIGURATION_BIT_TYPE_REPORT_ABUSE_NOTICE_ACKNOWLEDGED = 24;
  CONFIGURATION_BIT_TYPE_UNICORN_USE_CHILD_PRODUCT = 25;
  CONFIGURATION_BIT_TYPE_UNICORN_FULLY_DISABLED_BY_PARENT = 26;
  CONFIGURATION_BIT_TYPE_PHONE_VERIFICATION_MOBILE_PROMPT_SHOWN = 27;
  CONFIGURATION_BIT_TYPE_CAN_USE_GV_CALLER_ID_FEATURE = 28;
  CONFIGURATION_BIT_TYPE_PHOTO_SERVICE_REGISTERED = 29;
  CONFIGURATION_BIT_TYPE_GV_CALLER_ID_WABEL_FIRST_TIME_DIALOG_SHOWN = 30;
  CONFIGURATION_BIT_TYPE_HANGOUT_P2P_NOTICE_NEEDS_ACKNOWLEDGEMENT = 31;
  CONFIGURATION_BIT_TYPE_HANGOUT_P2P_ENABLED = 32;
  CONFIGURATION_BIT_TYPE_INVITE_NOTIFICATIONS_ENABLED = 33;
  CONFIGURATION_BIT_TYPE_DESKTOP_AUTO_EMOJI_CONVERSION_ENABLED = 34;
  CONFIGURATION_BIT_TYPE_WARM_WELCOME_SEEN = 35;
  CONFIGURATION_BIT_TYPE_INVITE_HAPPY_STATE_PROMO_SEEN = 36;
  CONFIGURATION_BIT_TYPE_DESKTOP_HOST_DENSITY_SETTINGS_ENABLED = 37;
  CONFIGURATION_BIT_TYPE_DESKTOP_COMPACT_MODE_ENABLED = 38;
}

message ConfigurationBit {
  optional ConfigurationBitType configuration_bit_type = 1;
  optional bool value = 2;
}

enum RichPresenceType {
  RICH_PRESENCE_TYPE_UNKNOWN = 0;
  RICH_PRESENCE_TYPE_IN_CALL_STATE = 1;
  RICH_PRESENCE_TYPE_DEVICE = 2;
  RICH_PRESENCE_TYPE_MOOD = 3;
  RICH_PRESENCE_TYPE_ACTIVITY = 4;
  RICH_PRESENCE_TYPE_GLOBALLY_ENABLED = 5;
  RICH_PRESENCE_TYPE_LAST_SEEN = 6;
}

message RichPresenceState {
  repeated RichPresenceEnabledState get_rich_presence_enabled_state = 3;
}

message RichPresenceEnabledState {
  optional RichPresenceType type = 1;
  optional bool enabled = 2;
}

enum FieldMask {
  FIELD_MASK_REACHABLE = 1;
  FIELD_MASK_AVAILABLE = 2;
  FIELD_MASK_MOOD = 3;
  FIELD_MASK_LOCATION = 4;
  FIELD_MASK_IN_CALL = 6;
  FIELD_MASK_DEVICE = 7;
  FIELD_MASK_LAST_SEEN = 10;

  // TODO: 5,8,9?
  //5 - mood, 3 is statusmessage
  //8 - activity
  //9 - calendarpresence
}

message DesktopOffSetting {
  // State of "desktop off" setting.
  optional bool desktop_off = 1;
}

message DesktopOffState {
  // Whether Hangouts desktop is signed off or on.
  optional bool desktop_off = 1;
  optional uint64 version = 2;
}

// Enable or disable do-not-disturb mode. Not to be confused with
// DoNotDisturbSetting, which is used to indicate the state of do-not-disturb
// mode.
message DndSetting {
  // Whether to enable or disable do-not-disturb mode.
  optional bool do_not_disturb = 1;
  // Do not disturb expiration in seconds.
  optional uint64 timeout_secs = 2;
}

message PresenceStateSetting {
  optional uint64 timeout_secs = 1;
  optional ClientPresenceStateType type = 2;
}

message MoodMessage {
  optional MoodContent mood_content = 1;
}

message MoodContent {
  repeated Segment segment = 1;
}

// The user's mood message.
message MoodSetting {
  optional MoodMessage mood_message = 1;
}

message MoodState {
  //repeated InCallState in_call_array = 2;
  //repeated RichPresenceEnabledState rich_presence_enabled = 3;
  optional MoodSetting mood_setting = 4;
}

enum DeleteType {
  DELETE_TYPE_UNKNOWN = 0;
  DELETE_TYPE_UPPER_BOUND = 1;
  DELETE_TYPE_PER_EVENT = 2;
}

message DeleteAction {
  optional uint64 delete_action_timestamp = 1;
  optional uint64 delete_upper_bound_timestamp = 2;
  optional DeleteType delete_type = 3;
}

message InviteeID {
  optional string gaia_id = 1;
  optional string circle_id = 2;
  optional string chat_id = 3;
  optional string fallback_name = 4;
}

enum SyncFilter {
  SYNC_FILTER_UNKNOWN = 0;
  SYNC_FILTER_INBOX = 1;
  SYNC_FILTER_ARCHIVED = 2;
  SYNC_FILTER_ACTIVE = 3;
  SYNC_FILTER_INVITED = 4;
  SYNC_FILTER_INVITED_LOW_AFFINITY = 5;
}

// Describes a user's country.
message Country {
  // Abbreviated region code (eg. "CA").
  optional string region_code = 1;
  // Country's calling code (eg. "1").
  optional uint64 country_code = 2;
}

enum SoundState {
  SOUND_STATE_UNKNOWN = 0;
  SOUND_STATE_ON = 1;
  SOUND_STATE_OFF = 2;
}

// Sound settings in the desktop Hangouts client.
message DesktopSoundSetting {
  // Whether to play sound for incoming messages.
  optional SoundState desktop_sound_state = 1;
  // Whether to ring for incoming calls.
  optional SoundState desktop_ring_sound_state = 2;
}

enum CallerIdSettingsMask {
  CALLER_ID_SETTINGS_MASK_UNKNOWN = 0;
  CALLER_ID_SETTINGS_MASK_PROVIDED = 1;
}

message PhoneData {
  repeated Phone phone = 1;
  //repeated CallerIdSetting caller_id_setting = 2;
  optional CallerIdSettingsMask caller_id_settings_mask = 3;
}

enum PhoneVerificationStatus {
  PHONE_VERIFICATION_STATUS_UNKNOWN = 0;
  PHONE_VERIFICATION_STATUS_VERIFIED = 1;
}

enum PhoneDiscoverabilityStatus {
  PHONE_DISCOVERABILITY_STATUS_UNKNOWN = 0;
  PHONE_DISCOVERABILITY_STATUS_OPTED_IN_AND_DISCOVERABLE = 1;
  PHONE_DISCOVERABILITY_STATUS_OPTED_IN_BUT_NOT_DISCOVERABLE = 2;
  PHONE_DISCOVERABILITY_STATUS_OPTED_OUT = 3;
}

message Phone {
  optional PhoneNumber phone_number = 1;
  optional bool google_voice = 2;
  optional PhoneVerificationStatus verification_status = 3;
  optional bool discoverable = 4;
  optional PhoneDiscoverabilityStatus discoverability_status = 5;
  optional bool primary = 6;
}

enum PhoneValidationResult {
  PHONE_VALIDATION_RESULT_IS_POSSIBLE = 0;
}

message I18nData {
  optional string national_number = 1;
  optional string international_number = 2;
  optional uint64 country_code = 3;
  optional string region_code = 4;
  optional bool is_valid = 5;
  optional PhoneValidationResult validation_result = 6;
}

message PhoneNumber {
  // Phone number as string (eg. "+15551234567").
  optional string e164 = 1;
  optional I18nData i18n_data = 2;
}

message SuggestedContactGroupHash {
  // Number of results to return from this group.
  optional uint64 max_results = 1;
  // An optional 4-byte hash. If this matches the server's hash, no results
  // will be sent.
  optional bytes hash = 2;
}

message SuggestedContact {
  // The contact's entity.
  optional Entity entity = 1;
  // The contact's invitation status.
  optional InvitationStatus invitation_status = 2;
}

message SuggestedContactGroup {
  // True if the request's hash matched and no contacts will be included.
  optional bool hash_matched = 1;
  // A 4-byte hash which can be used in subsequent requests.
  optional bytes hash = 2;
  // List of contacts in this group.
  repeated SuggestedContact contact = 3;
}

// ----------------------------------------------------------------------------
// State Update and Notifications
// ----------------------------------------------------------------------------

// Pushed from the server to the client to notify it of state changes. Includes
// exactly one type of notification, and optionally updates the attributes of a
// conversation.
message StateUpdate {

  optional StateUpdateHeader state_update_header = 1;

  // If set, includes conversation attributes that have been updated by the
  // notification.
  optional Conversation conversation = 13;

  //TODO implement in pblite handler
  //oneof state_update {

  optional  ConversationNotification conversation_notification = 2;
  optional  EventNotification event_notification = 3;
  optional  SetFocusNotification focus_notification = 4;
  optional  SetTypingNotification typing_notification = 5;
  optional  SetConversationNotificationLevelNotification notification_level_notification = 6;
  optional  ReplyToInviteNotification reply_to_invite_notification = 7;
  optional  WatermarkNotification watermark_notification = 8;
  
  // optional  //UnimplementedMessage unknown_1 = 9;
  // optional  //UnimplementedMessage settings_notification = 10;
    // TODO: rename to ViewModificationNotification?

  
  optional  ConversationViewModification view_modification = 11;
  optional  EasterEggNotification easter_egg_notification = 12;
  optional  SelfPresenceNotification self_presence_notification = 14;
  optional  DeleteActionNotification delete_notification = 15;
  optional  PresenceNotification presence_notification = 16;
  optional  BlockNotification block_notification = 17;
  
  // optional  InvitationWartermarkNotification invitation_watermark_notification = 18;
  
  optional  SetNotificationSettingNotification notification_setting_notification = 19;
  optional  RichPresenceEnabledStateNotification rich_presence_enabled_state_notification = 20;
  
  //optional ContactsNotification contacts_notification = 21;
  //optional ConversationDeliveryMediumModification delivery_medium_modification = 23;
  //optional CallerIdConfigNotification caller_id_config_notification = 28;
  //optional  EventSeenNotification event_seen_notification = 30;
  //}
  //optional GlobalNotificationLevelNotification global_notification_level_notification = 31;
}

// Header for StateUpdate messages.
message StateUpdateHeader {
  optional ActiveClientState active_client_state = 1;
  optional string request_trace_id = 3;
  optional NotificationSettings notification_settings = 4;
  optional uint64 current_server_time = 5;

  // TODO:
  // optional UserSettings self_settings (dnd_state) = 2;
  // optional ArchiveSettings archive_settings (is_babel_user) = 6
  // optional string client_generated_request_id = 7;
  // optional ID of the client causing the update
  // optional string self_fanout_id = 8;
}

// List of StateUpdate messages to allow pushing multiple notifications from
// the server to the client simultaneously.
message BatchUpdate {
  repeated StateUpdate state_update = 1;
}

message ConversationNotification {
  optional Conversation conversation = 1;
}

message EventNotification {
  optional Event event = 1;
}

message SetFocusNotification {
  optional ConversationId conversation_id = 1;
  optional ParticipantId sender_id = 2;
  optional uint64 timestamp = 3;
  optional FocusType type = 4;
  //optional FocusDevice device = 5;
  //optional uint32 timeout_secs = 5;
}

message SetTypingNotification {
  optional ConversationId conversation_id = 1;
  optional ParticipantId sender_id = 2;
  optional uint64 timestamp = 3;
  optional TypingType type = 4;
}

message SetConversationNotificationLevelNotification {
  optional ConversationId conversation_id = 1;
  optional NotificationLevel level = 2;
  optional uint32 revert_timeout_secs = 3;
  optional uint64 timestamp = 4;
}

message ReplyToInviteNotification {
  optional ConversationId conversation_id = 1;
  optional ReplyToInviteType type = 2;

  // TODO: untested
}

message WatermarkNotification {
  optional ParticipantId sender_id = 1;
  optional ConversationId conversation_id = 2;
  optional uint64 latest_read_timestamp = 3;
}

message ConversationViewModification {
  optional ConversationId conversation_id = 1;
  optional ConversationView old_view = 2;
  optional ConversationView new_view = 3;
}

message GroupLinkSharingModification {
  optional GroupLinkSharingStatus new_status = 1;
}

message EasterEggNotification {
  optional ParticipantId sender_id = 1;
  optional ConversationId conversation_id = 2;
  optional EasterEgg easter_egg = 3;
}

// Notifies the status of other clients and mood.
message SelfPresenceNotification {
  optional ClientPresenceState client_presence_state = 1;
  //optional ClientPresence presence = 2;
  optional DoNotDisturbSetting do_not_disturb_setting = 3;
  optional DesktopOffSetting desktop_off_setting = 4;
  optional DesktopOffState desktop_off_state = 5;
  optional MoodState mood_state = 6;
}

message DeleteActionNotification {
  optional ConversationId conversation_id = 1;
  optional DeleteAction delete_action = 2;
}

message PresenceNotification {
  repeated PresenceResult presence = 1;
}

message BlockNotification {
  repeated BlockStateChange block_state_change = 1;
}

message InvitationWatermarkNotification {
  optional InvitationState state = 1;
}

message SetNotificationSettingNotification {
  repeated ConfigurationBit configuration_bit = 1;
  optional DesktopSoundSetting desktop_sound_setting = 2;
}

message RichPresenceEnabledStateNotification {
  repeated RichPresenceEnabledState rich_presence_enabled_state = 1;
}

message ConversationSpec {
  optional ConversationId conversation_id = 1;
  optional ParticipantId participant_id = 2;
  optional InviteeID invitee_id = 3;
}

// message ConversationEventSeenNotification {
  // repeated ConversationEventsSeen conversation_events = 1;
// }

// message ConversationEventsSeen {
  // optional ConversationId conversation_id = 1;
  // repeated EventSeen event_seen = 2;
// }

// message EventSeen {
  // optional string event_id = 1;
  // optional uint64 event_timestamp = 2;
  // optional uint64 unknown_type = 3;
// }

enum OffnetworkAddressType {
  OFFNETWORK_ADDRESS_TYPE_UNKNOWN = 0; //PHONE
  OFFNETWORK_ADDRESS_TYPE_EMAIL = 1;
}

message OffnetworkAddress {
  optional OffnetworkAddressType type = 1;
  //optional string phone = 2;
  optional string email = 3;
}

enum GroupLinkSharingStatus {
  GROUP_LINK_SHARING_STATUS_UNKNOWN = 0;
  GROUP_LINK_SHARING_STATUS_ON = 1;
  GROUP_LINK_SHARING_STATUS_OFF = 2;
  GROUP_LINK_SHARING_STATUS_NOT_AVAILABLE = 3;
}

// ----------------------------------------------------------------------------
// Requests & Responses
// ----------------------------------------------------------------------------

message AddUserRequest {
  optional RequestHeader request_header = 1;
  repeated InviteeID invitee_id = 3;
  optional EventRequestHeader event_request_header = 5;
}

message AddUserResponse {
  optional ResponseHeader response_header = 1;
  optional Event created_event = 5;
  
  //repeated InviteeError invitee_error = 2;
  //optional Conversation updated_conversation = 6;
}

message CreateConversationRequest {
  optional RequestHeader request_header = 1;
  optional ConversationType type = 2;
  optional uint64 client_generated_id = 3;
  optional string name = 4;
  repeated InviteeID invitee_id = 5;
  
  //optional DeliveryMedium delivery_medium = 11;
  //optional InviteToken invite_token = 12;
  //optional string conversation_avatar_media_key = 14;
}

message CreateConversationResponse {
  optional ResponseHeader response_header = 1;
  optional Conversation conversation = 2;
  optional bool new_conversation_created = 7;
  
  //repeated InviteeError invitee_error = 3;
}

message DeleteConversationRequest {
  optional RequestHeader request_header = 1;
  optional ConversationId conversation_id = 2;
  optional uint64 delete_upper_bound_timestamp = 3;
}

message DeleteConversationResponse {
  optional ResponseHeader response_header = 1;
  optional DeleteAction delete_action = 2;
}

message EasterEggRequest {
  optional RequestHeader request_header = 1;
  optional ConversationId conversation_id = 2;
  optional EasterEgg easter_egg = 3;
}

message EasterEggResponse {
  optional ResponseHeader response_header = 1;
  optional uint64 timestamp = 2;
}

message GetConversationRequest {
  optional RequestHeader request_header = 1;
  optional ConversationSpec conversation_spec = 2;
  optional bool include_conversation_metadata = 3;
  optional bool include_event = 4;
  optional uint64 max_events_per_conversation = 6;
  optional EventContinuationToken event_continuation_token = 7;
  optional bool include_presence = 8;

  // TODO:
  // unknown = 5;
  //optional EventContinuationToken forward_continuation_token = 11;
}

message GetConversationResponse {
  optional ResponseHeader response_header = 1;
  optional ConversationState conversation_state = 2;
  //optional GetConversationError error = 3;
  optional PresenceResult presence = 4;
}

message GetEntityByIdRequest {
  optional RequestHeader request_header = 1;
  optional EntityLookupSpec lookup_spec = 2;
  repeated EntityLookupSpec batch_lookup_spec = 3;
  repeated FieldMask field_mask = 4;
}

message GetEntityByIdResponse {
  optional ResponseHeader response_header = 1;
  // Resulting entities of PARTICIPANT_TYPE_GAIA only.
  repeated Entity entity = 2;
  // All resulting entities.
  repeated EntityResult entity_result = 3;
}

message EntityResult {
  optional EntityLookupSpec lookup_spec = 1;
  repeated Entity entity = 2;
}

message GetGroupConversationUrlRequest {
  optional RequestHeader request_header = 1;
  optional ConversationId conversation_id = 2;
}

message GetGroupConversationUrlResponse {
  optional ResponseHeader response_header = 1;
  // URL for others to join the conversation.
  optional string group_conversation_url = 2;
}

message GetSuggestedEntitiesRequest {
  optional RequestHeader request_header = 1;
  // Max number of non-grouped entities to return.
  optional uint64 max_count = 4;
  // Optional hash for "favorites" contact group.
  optional SuggestedContactGroupHash favorites = 8;
  // Optional hash for "contacts you hangout with" contact group.
  optional SuggestedContactGroupHash contacts_you_hangout_with = 9;
  // Optional hash for "other contacts on hangouts" contact group.
  optional SuggestedContactGroupHash other_contacts_on_hangouts = 10;
  // Optional hash for "other contacts" contact group.
  optional SuggestedContactGroupHash other_contacts = 11;
  // Optional hash for "dismissed contacts" contact group.
  optional SuggestedContactGroupHash dismissed_contacts = 12;
  // Optional hash for "pinned favorites" contact group.
  optional SuggestedContactGroupHash pinned_favorites = 13;

  // TODO: possible other fields:
  // repeated EntityID given_entity_id = 2
  // repeated EntityFilterType entity_type_filter = 3;
  // optional bool include_availability = 5;
  // repeated ParticipantId given_entity_id = 6
  // optional bool include_legacy = 7;
  // optional bool include_is_babel_user = 14;
  // repeated int additional_entity_data = 15;
}

message GetSuggestedEntitiesResponse {
  optional ResponseHeader response_header = 1;
  repeated Entity entity = 2;
  //optional bool scoring_failed = 3;
  optional SuggestedContactGroup favorites = 4;
  optional SuggestedContactGroup contacts_you_hangout_with = 5;
  optional SuggestedContactGroup other_contacts_on_hangouts = 6;
  optional SuggestedContactGroup other_contacts = 7;
  optional SuggestedContactGroup dismissed_contacts = 8;
  optional SuggestedContactGroup pinned_favorites = 9;
}

message GetSelfInfoRequest {
  optional RequestHeader request_header = 1;

  // TODO
  // repeated ClientRequestedFieldMask required_fields = 2;
  // repeated ClientRequestedFieldMask optional_fields = 3;
  // optional bool upgrade_to_babel = 4;
}

message GetSelfInfoResponse {
  optional ResponseHeader response_header = 1;
  optional Entity self_entity = 2;
  optional bool is_known_minor = 3;
  repeated ClientPresenceState client_presence = 4;
  optional DoNotDisturbSetting dnd_state = 5;
  optional DesktopOffSetting desktop_off_setting = 6;
  optional PhoneData phone_data = 7;
  repeated ConfigurationBit configuration_bit = 8;
  optional DesktopOffState desktop_off_state = 9;
  optional bool google_plus_user = 10;
  optional DesktopSoundSetting desktop_sound_setting = 11;
  optional RichPresenceState rich_presence_state = 12;
  optional Country default_country = 19;

  // TODO:
  // optional bool babel_user = 13;
  // optional bool desktop_availability_sharing_enabled = 14;
  // enum desktop_html5_notification_state? = 16;
  // optional bool google_plus_mobile_user = 15;
  // repeated ParticipantId managed_plus_page = 17;
  // optional AccountAgeGroup account_age_group = 18;
  // repeated ExperimentValue mobile_experiment = 20;
  // unknown = 22;
  // optional NotificationLevel default_notification_level = 24;
}

message ModifyConversationViewRequest {
  optional RequestHeader request_header = 1;
  optional ConversationId conversation_id = 2;
  optional ConversationView new_view = 3;
  optional uint64 last_event_timestamp = 4;
}

message ModifyConversationViewResponse {
  optional ResponseHeader response_header = 1;
}

message OpenGroupConversationFromUrlRequest {
  optional RequestHeader request_header = 1;
  // optional EventRequestHeader event_request_header = 2;
  optional string url = 3;
}

message OpenGroupConversationFromUrlResponse {
  optional ResponseHeader response_header = 1;
  optional ConversationId conversation_id = 2;
}

message QueryPresenceRequest {
  optional RequestHeader request_header = 1;
  repeated ParticipantId participant_id = 2;
  repeated FieldMask field_mask = 3;
}

message QueryPresenceResponse {
  optional ResponseHeader response_header = 1;
  repeated PresenceResult presence_result = 2;
}

message RemoveUserRequest {
  optional RequestHeader request_header = 1;
  optional ConversationId conversation_id = 2;
  optional ParticipantId participant_id = 3;
  optional uint64 client_generated_id = 4;
  optional EventRequestHeader event_request_header = 5;
}

message RemoveUserResponse {
  optional ResponseHeader response_header = 1;
  optional uint64 timestamp = 2;
  optional string event_id = 3;
  optional Event created_event = 4;
  optional Conversation updated_conversation = 5;
}

message RenameConversationRequest {
  optional RequestHeader request_header = 1;
  optional ConversationId conversation_id = 2;
  optional string new_name = 3;
  optional uint64 client_generated_id = 4;
  optional EventRequestHeader event_request_header = 5;
}

message RenameConversationResponse {
  optional ResponseHeader response_header = 1;
  optional uint64 timestamp = 2;
  optional string event_id = 3;
  optional Event created_event = 4;
  optional Conversation updated_conversation = 5;
}

message SearchEntitiesRequest {
  optional RequestHeader request_header = 1;
  optional string query = 3;
  optional uint64 max_count = 4;
  
  // optional bool include_pages = 6;
  // optional bool include_is_babel_user = 7;
  // repeated AdditionalEntityData additional_entity_data = 8;
  // optional int32 max_conversation_count = 9;
}

message SearchEntitiesResponse {
  optional ResponseHeader response_header = 1;
  repeated Entity entity = 2;
}

message SendChatMessageRequest {
  optional RequestHeader request_header = 1;
  optional ConversationId conversation_id = 2;
  optional uint64 client_generated_id = 3;
  repeated EventAnnotation annotation = 5;
  optional MessageContent message_content = 6;
  optional ExistingMedia existing_media = 7;
  optional EventRequestHeader event_request_header = 8;
  optional InviteeID other_invitee_id = 9;
  //optional LocationSpec attach_location = 10;
  //optional ExternalImageSpec external_image_spec = 11;
  //repeated ChatMessageSpec chat_message_spec = 12;
}

message SendChatMessageResponse {
  optional ResponseHeader response_header = 1;
  optional uint64 timestamp = 2;
  optional string event_id = 3;
  //repeated MediaUploadInfo media_upload_info = 4;
  //optional EventHeader event_header = 5;
  optional Event created_event = 6;
  optional Conversation updated_conversation = 7;
}

message ModifyOTRStatusRequest {
  optional RequestHeader request_header = 1;
  optional OffTheRecordStatus otr_status = 3;
  optional EventRequestHeader event_request_header = 5;
}

message ModifyOTRStatusResponse {
  optional ResponseHeader response_header = 1;
  optional Event created_event = 4;
  //optional Conversation updated_conversation = 5;
  //optional bool otr_unmodified = 6;
}

message SendOffnetworkInvitationRequest {
  optional RequestHeader request_header = 1;
  optional OffnetworkAddress invitee_address = 2;
}

message SendOffnetworkInvitationResponse {
  optional ResponseHeader response_header = 1;
  //optional OffnetworkInvitationError error = 2;
}

message SetActiveClientRequest {
  optional RequestHeader request_header = 1;
  // Whether to set the client as active or inactive.
  optional bool is_active = 2;
  // 'email/resource'.
  optional string full_jid = 3;
  // Timeout in seconds for client to remain active.
  optional uint64 timeout_secs = 4;

  // optional bool update_last_seen_timestamp = 5;
}

message SetActiveClientResponse {
  optional ResponseHeader response_header = 1;
  //optional ClientSetActiveClientError serror = 2;
  optional uint64 client_last_seen_timestamp_usec = 3;
  optional uint64 last_seen_delta_usec = 4;
}

message SetConversationLevelRequest {
  optional RequestHeader request_header = 1;
  optional ConversationId conversation_id = 2;
  optional NotificationLevel level = 3;
  optional uint32 revert_timeout_secs = 4;
}

message SetConversationLevelResponse {
  optional ResponseHeader response_header = 1;
  optional uint64 timestamp = 2;
}

message SetConversationNotificationLevelRequest {
  optional RequestHeader request_header = 1;
  optional ConversationId conversation_id = 2;
  optional NotificationLevel level = 3;
}

message SetConversationNotificationLevelResponse {
  optional ResponseHeader response_header = 1;
  optional uint64 timestamp = 2;
}

message SetFocusRequest {
  optional RequestHeader request_header = 1;
  optional ConversationId conversation_id = 2;
  optional FocusType type = 3;
  optional uint32 timeout_secs = 4;
}

message SetFocusResponse {
  optional ResponseHeader response_header = 1;
  optional uint64 timestamp = 2;
}

message SetGroupLinkSharingEnabledRequest {
  optional RequestHeader request_header = 1;
  optional EventRequestHeader event_request_header = 2;
  // New group link sharing status.
  optional GroupLinkSharingStatus group_link_sharing_status = 4;

}

message SetGroupLinkSharingEnabledResponse {
  optional ResponseHeader response_header = 1;
  // Created event of type EVENT_TYPE_GROUP_LINK_SHARING_MODIFICATION.
  optional Event created_event = 2;
  // Updated conversation.
  optional Conversation updated_conversation = 3;
}


// Allows setting one or more of the included presence-related settings.
message SetPresenceRequest {
  optional RequestHeader request_header = 1;
  optional PresenceStateSetting presence_state_setting = 2;
  optional DndSetting dnd_setting = 3;
  optional DesktopOffSetting desktop_off_setting = 5;
  //optional InCallSetting in_call_setting = 7;
  optional MoodSetting mood_setting = 8;
}

message SetPresenceResponse {
  optional ResponseHeader response_header = 1;
}

message SetTypingRequest {
  optional RequestHeader request_header = 1;
  optional ConversationId conversation_id = 2;
  optional TypingType type = 3;
}

message SetTypingResponse {
  optional ResponseHeader response_header = 1;
  optional uint64 timestamp = 2;
}

message UnreadConversationState {
  optional ConversationId conversation_id = 1;
  optional uint64 timestamp = 2;
}

message SyncAllNewEventsRequest {
  optional RequestHeader request_header = 1;
  // Timestamp after which to return all new events.
  optional uint64 last_sync_timestamp = 2;
  //repeated LocalState local_state = 3;
  optional uint64 max_total_events = 4;
  repeated SyncFilter sync_filter = 5;
  optional bool no_missed_events_expected = 6;
  optional UnreadConversationState unread_state = 7;
  optional uint64 max_response_size_bytes = 8;
}

message SyncAllNewEventsResponse {
  optional ResponseHeader response_header = 1;
  optional uint64 sync_timestamp = 2;
  repeated ConversationState conversation_state = 3;
  optional bool conversation_ids_only = 4;
  optional InvitationState invitation_state = 5;
  optional bool clear_cache_and_resync = 6;
}

message SyncRecentConversationsRequest {
  optional RequestHeader request_header = 1;
  optional uint64 end_timestamp = 2;
  optional uint64 max_conversations = 3;
  optional uint64 max_events_per_conversation = 4;
  repeated SyncFilter sync_filter = 5;
}

message SyncRecentConversationsResponse {
  optional ResponseHeader response_header = 1;
  optional uint64 sync_timestamp = 2;
  repeated ConversationState conversation_state = 3;
  optional uint64 continuation_end_timestamp = 4;
  optional InvitationState invitation_state = 5;
}

message UpdateWatermarkRequest {
  optional RequestHeader request_header = 1;
  optional ConversationId conversation_id = 2;
  optional uint64 last_read_timestamp = 3;
}

message UpdateWatermarkResponse {
  optional ResponseHeader response_header = 1;
}
